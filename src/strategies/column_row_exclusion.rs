use board::Board;
use std::ops::Range;
use sudoku_cell_bitmask;

const BLOCK_COMBINATIONS: [(usize, usize, usize); 9] = [
	(0, 1, 2),
	(2, 0, 1),
	(1, 2, 0),
	(3, 4, 5),
	(5, 3, 4),
	(4, 5, 3),
	(6, 7, 8),
	(8, 6, 7),
	(7, 8, 6),
]; 

const CELL_COMBINATIONS: [Range<usize>; 3] = [
	(0..3),
	(3..6),
	(6..9),
];

pub fn solve(board: &mut Board) {
	for &(y_a, y_b, block_exclusion) in BLOCK_COMBINATIONS.iter() {
		for candidate_range in CELL_COMBINATIONS.iter() {
			let mut possible_candidates = 0x1FF;

			// rows
			for x in candidate_range.clone() {
				possible_candidates &= !board.candidates[y_a][x];
				possible_candidates &= !board.candidates[y_b][x];
			}

			if possible_candidates != 0 {
				for x in (0..9) {
					if x >= candidate_range.start && x < candidate_range.end { continue }

				    board.candidates[block_exclusion][x] &= !possible_candidates;
				}
			}
		}
	}

	for &(x_a, x_b, block_exclusion) in BLOCK_COMBINATIONS.iter() {
		for candidate_range in CELL_COMBINATIONS.iter() {
			let mut possible_candidates = 0x1FF;

			// columns
			for y in candidate_range.clone() {
				possible_candidates &= !board.candidates[y][x_a];
				possible_candidates &= !board.candidates[y][x_b];
			}

			if possible_candidates != 0 {
				for y in (0..9) {
					if y >= candidate_range.start && y < candidate_range.end { continue }

				    board.candidates[y][block_exclusion] &= !possible_candidates;
				}
			}
		}
	}
}

#[cfg(test)]
mod test {
	use super::*;

	#[test]
	fn solves_column_exclusion() {
		let initial_values = vec![
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 7, 0, 8, 0, 0, 0,],
			vec![0, 0, 0, 3, 0, 9, 0, 0, 0,],
			vec![5, 0, 0, 0, 0, 0, 0, 0, 0,],
		];
		let mut board = Board::new(initial_values);
		board.candidates = [
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1FF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1FF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1FF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1FF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1FF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1FF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x12F, 0x12F, 0x12F, 0x040, 0x03B, 0x080, 0x13F, 0x13F, 0x13F,],
		    [0x0EB, 0x0EB, 0x0EB, 0x004, 0x03B, 0x100, 0x0FB, 0x0FB, 0x0FB,],
		    [0x010, 0x1EF, 0x1EF, 0x02B, 0x02B, 0x02B, 0x1EF, 0x1EF, 0x1EF,],
		]; 

		solve(&mut board);

		assert_eq!([
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1EF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1EF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1EF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1EF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1EF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x1EF, 0x1FF, 0x1FF, 0x1BB, 0x1EF, 0x07F, 0x1FF, 0x1FF, 0x1FF,],
		    [0x12F, 0x12F, 0x12F, 0x040, 0x03B, 0x080, 0x13F, 0x13F, 0x13F,],
		    [0x0EB, 0x0EB, 0x0EB, 0x004, 0x03B, 0x100, 0x0FB, 0x0FB, 0x0FB,],
		    [0x010, 0x1EF, 0x1EF, 0x02B, 0x02B, 0x02B, 0x1EF, 0x1EF, 0x1EF,],
		], board.candidates);
	}

	#[test]
	fn solves_row_exclusion() {
		let initial_values = vec![
			vec![0, 0, 0, 0, 7, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 2, 0, 1, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 9, 0, 6, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
			vec![0, 0, 0, 0, 0, 0, 0, 0, 0,],
		];
		let mut board = Board::new(initial_values);
		board.candidates = [
			[0x1BF, 0x1BF, 0x1BF, 0x0BD, 0x040, 0x1BF, 0x1BF, 0x1BF, 0x1BF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FC, 0x1FC, 0x1FC, 0x002, 0x1BF, 0x001, 0x1FC, 0x1FC, 0x1FC,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x0DF, 0x0DF, 0x0DF, 0x100, 0x1BF, 0x020, 0x0DF, 0x0DF, 0x0DF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
		]; // candidates with sole candidates already applied

		solve(&mut board);

		// 0x1BF = any candidate except 7
		assert_eq!([
			[0x1BF, 0x1BF, 0x1BF, 0x0BD, 0x040, 0x1BF, 0x1BF, 0x1BF, 0x1BF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FC, 0x1FC, 0x1FC, 0x002, 0x1BF, 0x001, 0x1FC, 0x1FC, 0x1FC,],
			[0x1BF, 0x1BF, 0x1BF, 0x0FD, 0x1BF, 0x1DE, 0x1BF, 0x1BF, 0x1BF,], // Notice the difference here
			[0x0DF, 0x0DF, 0x0DF, 0x100, 0x1BF, 0x020, 0x0DF, 0x0DF, 0x0DF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
			[0x1FF, 0x1FF, 0x1FF, 0x0FD, 0x1BF, 0x1DE, 0x1FF, 0x1FF, 0x1FF,],
		], board.candidates);
	}
}
